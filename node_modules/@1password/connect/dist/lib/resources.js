"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Items = exports.Vaults = void 0;
const models_1 = require("../model/models");
class OPResource {
    constructor(adapter) {
        this.adapter = adapter;
    }
}
class Vaults extends OPResource {
    constructor() {
        super(...arguments);
        this.basePath = "v1/vaults";
    }
    /**
     * Return all vaults the Service Account has permission to view.
     */
    list() {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.adapter.sendRequest("get", `${this.basePath}/`);
            return models_1.ObjectSerializer.deserialize(data, "Array<Vault>");
        });
    }
    /**
     * Fetch basic information about all items in specified Vault
     *
     * @param vaultId
     */
    listItems(vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.adapter.sendRequest("get", `${this.basePath}/${vaultId}/items`);
            return models_1.ObjectSerializer.deserialize(data, "Array<Item>");
        });
    }
    /**
     * Get metadata about a single vault
     *
     * @param vaultId
     */
    getVault(vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.adapter.sendRequest("get", `${this.basePath}/${vaultId}`);
            return models_1.ObjectSerializer.deserialize(data, "Vault");
        });
    }
}
exports.Vaults = Vaults;
class Items extends OPResource {
    constructor() {
        super(...arguments);
        this.basePath = (vaultId, itemId) => itemId && typeof itemId !== "undefined"
            ? `v1/vaults/${vaultId}/items/${itemId}`
            : `v1/vaults/${vaultId}/items/`;
    }
    create(vaultId, item) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.adapter.sendRequest("post", this.basePath(vaultId), {
                data: models_1.ObjectSerializer.serialize(item, "FullItem"),
            });
            return models_1.ObjectSerializer.deserialize(data, "FullItem");
        });
    }
    update(vaultId, item) {
        return __awaiter(this, void 0, void 0, function* () {
            const { data } = yield this.adapter.sendRequest("put", this.basePath(vaultId, item.id), { data: models_1.ObjectSerializer.serialize(item, "FullItem") });
            return models_1.ObjectSerializer.deserialize(data, "FullItem");
        });
    }
    get(vaultId, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(opts.itemId || opts.title) || (opts.itemId && opts.title)) {
                throw TypeError("Items.get() requires itemId or title");
            }
            const { data } = opts.itemId
                ? yield this.getById(vaultId, opts.itemId)
                : yield this.getByTitle(vaultId, opts.title);
            return models_1.ObjectSerializer.deserialize(data, "FullItem");
        });
    }
    delete(vaultId, itemId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.adapter.sendRequest("delete", this.basePath(vaultId, itemId));
        });
    }
    getById(vaultId, itemId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.adapter.sendRequest("get", this.basePath(vaultId, itemId));
        });
    }
    /**
     * Searches for an Item with a case-sensitive, exact match on title.
     * If found, queries for complete item details and returns result.
     *
     * @param {string} vaultId
     * @param {string} title
     * @returns {Promise<FullItem>}
     * @private
     */
    getByTitle(vaultId, title) {
        return __awaiter(this, void 0, void 0, function* () {
            const queryPath = `${this.basePath(vaultId)}?filter=title eq "${title}"`;
            const { data } = yield this.adapter.sendRequest("get", queryPath);
            if (!(data === null || data === void 0 ? void 0 : data.length)) {
                return Promise.reject({
                    status: 404,
                    message: "No Items found with title",
                });
            }
            if (data.length > 1) {
                return Promise.reject({
                    status: 400,
                    message: "Found multiple Items with given title. Provide a more specific Item title",
                });
            }
            return this.getById(data[0].vault.id, data[0].id);
        });
    }
}
exports.Items = Items;
//# sourceMappingURL=resources.js.map