"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ItemBuilder = void 0;
const crypto = __importStar(require("crypto"));
const debug_1 = __importDefault(require("debug"));
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const slug_1 = __importDefault(require("slug"));
const models_1 = require("../model/models");
const debug = debug_1.default("opconnect:builder");
class ItemBuilder {
    constructor() {
        this.reset();
    }
    /**
     * Performs final assembly of the new Item.
     */
    build() {
        if (!this.item.category) {
            throw Error("Item Category is required.");
        }
        this.item.sections = Array.from(this.sections.values());
        this.item.urls = this.urls.hrefs.map((href) => this.urls.primaryUrl === href
            ? { primary: true, href }
            : { href });
        const builtItem = lodash_clonedeep_1.default(this.item);
        debug("Successfully built Item (id: %s, vault: %s)", builtItem.id);
        this.reset();
        return builtItem;
    }
    /**
     * Clears accumulated properties and puts
     * ItemBuilder back to a "pristine" state
     */
    reset() {
        this.item = new models_1.FullItem();
        this.item.fields = [];
        this.item.tags = [];
        this.sections = new Map();
        this.urls = { primaryUrl: "", hrefs: [] };
    }
    /**
     * @deprecated
     * Sets the parent Vault ID for the Item being constructed.
     *
     * @param {string} vaultId
     * @returns {ItemBuilder}
     */
    setVault(vaultId) {
        this.item.vault = { id: vaultId };
        return this;
    }
    /**
     * Set Title for the item under construction
     *
     * @param {string} title
     * @returns {ItemBuilder}
     */
    setTitle(title) {
        this.item.title = title;
        return this;
    }
    /**
     * Append new tag to list of tags
     * 1Password does not normalize tag inputs.
     *
     * @param {string} tag
     * @returns {ItemBuilder}
     */
    addTag(tag) {
        this.item.tags.push(tag);
        return this;
    }
    /**
     * Append new Item Field to the in-flight Item.
     *
     * @param {ItemFieldOptions} opts
     * @returns {ItemBuilder}
     */
    addField(opts = {}) {
        const field = {
            type: opts.type || models_1.FullItemAllOfFields.TypeEnum.String,
            purpose: opts.purpose || models_1.FullItemAllOfFields.PurposeEnum.Empty,
            label: opts.label,
            value: opts.value,
            generate: opts.generate || false,
            recipe: opts.generate ? {
                length: opts.recipe.length,
                characterSets: [...new Set(opts.recipe.characterSets)]
            } : undefined,
        };
        if (opts.sectionName) {
            const { id: sectionId } = this.getOrCreateSection(opts.sectionName);
            field.section = { id: sectionId };
        }
        if (opts.generate && !validRecipe(opts.recipe)) {
            throw TypeError(`Field '${opts.label}' contains an invalid Recipe.`);
        }
        this.item.fields.push(field);
        return this;
    }
    /**
     * Define a new section within the Item.
     *
     * If a section with the same (normalized) name
     * already exists, do nothing.
     *
     * @param sectionName
     * @returns {ItemBuilder}
     */
    addSection(sectionName) {
        this.getOrCreateSection(sectionName);
        return this;
    }
    /**
     * Toggle `favorite` value on the in-flight Item.
     *
     * @returns {ItemBuilder}
     */
    toggleFavorite() {
        this.item.favorite = !this.item.favorite;
        return this;
    }
    /**
     * Add a new URL to the Item.
     *
     * The **last** url marked `primary` will be the primary URL
     * when saved to 1Password.
     *
     * @param url
     * @returns {ItemBuilder}
     */
    addUrl(url) {
        if (url.primary)
            this.urls.primaryUrl = url.href;
        this.urls.hrefs.push(url.href);
        return this;
    }
    /**
     * Assign category to the Item under construction.
     *
     * @param category
     * @returns {ItemBuilder}
     */
    setCategory(category) {
        if (Object.values(models_1.FullItem.CategoryEnum).indexOf(category) === -1) {
            throw TypeError("Item Category is invalid");
        }
        this.item.category = category;
        return this;
    }
    /**
     * Creates a new Item Section if it does not exist. Otherwise, return the previously-created
     * Item Section.
     *
     * Normalizes sectionName as a slug (utf-8 chars are transformed to ascii).
     *
     * @param sectionName
     * @private
     * @return {FullItemAllOfSections}
     */
    getOrCreateSection(sectionName) {
        const normalizedName = slug_1.default(sectionName, { lower: true });
        if (this.sections.has(normalizedName)) {
            return this.sections.get(normalizedName);
        }
        // Note about Section IDs: these do NOT have to be cryptographically random.
        // Section IDs are only unique within an Item.
        const section = {
            id: generateSectionId(),
            label: sectionName,
        };
        this.sections.set(normalizedName, section);
        return section;
    }
}
exports.ItemBuilder = ItemBuilder;
/**
 * Evaluate Recipe parameters against allowed values.
 *
 * @param {GeneratorRecipe} recipe
 * @returns {boolean}
 */
const validRecipe = (recipe) => {
    if (!recipe.characterSets || !recipe.characterSets.length)
        return true;
    const allowedCharactersSets = Object.values(models_1.GeneratorRecipe.CharacterSetsEnum);
    // User provided more character sets than are defined
    if (recipe.characterSets.length > allowedCharactersSets.length)
        return false;
    for (const cs of recipe.characterSets) {
        if (allowedCharactersSets.indexOf(cs) === -1) {
            return false;
        }
    }
    return true;
};
/**
 * Create a sectionID from random bytes.
 *
 * Section IDs do not need to be cryptographically random.
 *
 * @param {number} length
 * @returns {string}
 */
const generateSectionId = (length) => crypto.randomBytes(length || 13).toString("hex");
//# sourceMappingURL=builders.js.map