"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.newConnectClient = void 0;
const resources_1 = require("./resources");
const client_1 = require("./client");
const requests_1 = require("./requests");
/**
 * OnePasswordConnect client factory.
 *
 * @param {OPConfig} opts
 * @returns {OPConnect}
 */
const newConnectClient = (opts) => {
    if (opts && typeof opts !== "object") {
        throw new TypeError("Options argument must be an object");
    }
    if (!opts.serverURL || !opts.token) {
        throw new Error("Options serverURL and token are required.");
    }
    return new OPConnect(opts);
};
exports.newConnectClient = newConnectClient;
class OPConnect {
    constructor(opts) {
        this.httpAdapter = new requests_1.RequestAdapter(opts.httpClient ? opts.httpClient : new client_1.HTTPClient(opts), { serverURL: opts.serverURL, token: opts.token });
        this.vaults = new resources_1.Vaults(this.httpAdapter);
        this.items = new resources_1.Items(this.httpAdapter);
    }
    /**
     * Returns a list of all Vaults the Service Account has permission
     * to view.
     *
     * @returns {Promise<Vault[]>}
     */
    listVaults() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.vaults.list();
        });
    }
    /**
     * Get details about a specific vault.
     *
     * If the Service Account does not have permission to view the vault, an
     * error is returned.
     *
     * @param {string} vaultId
     * @returns {Promise<Vault>}
     */
    getVault(vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.vaults.getVault(vaultId);
        });
    }
    /**
     * Lists all Items inside a specific Vault.
     *
     * @param {string} vaultId
     * @returns {Promise<SimpleItem[]>}
     */
    listItems(vaultId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.vaults.listItems(vaultId);
        });
    }
    /**
     * Get details about a specific Item in a Vault.
     *
     * @param {string} vaultId
     * @param {string} itemId
     * @returns {Promise<FullItem>}
     */
    getItem(vaultId, itemId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.items.get(vaultId, { itemId });
        });
    }
    /**
     * Get details about a specific item with a matching Title value.
     *
     * The Item Title is case-sensitive and must be an exact-match.
     *
     * @param {string} vaultId
     * @param {string} title
     * @returns {Promise<FullItem>}
     */
    getItemByTitle(vaultId, title) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.items.get(vaultId, { title });
        });
    }
    /**
     * Creates a new Item inside the specified Vault.
     *
     * @param {string} vaultId
     * @param {FullItem} item
     * @returns {Promise<FullItem>}
     */
    createItem(vaultId, item) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.items.create(vaultId, item);
        });
    }
    /**
     * Perform a replacement update of an Item. The given `item` object will
     * overwrite the existing item in the Vault.
     *
     * @param {string} vaultId
     * @param {FullItem} item
     * @returns {Promise<FullItem>}
     */
    updateItem(vaultId, item) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!item.id)
                throw Error("Item ID must be defined.");
            return yield this.items.update(vaultId, item);
        });
    }
    /**
     * Deletes a single Item matching the given Item ID.
     *
     * @param {string} vaultId
     * @param {string} itemId
     * @returns {Promise<void>}
     */
    deleteItem(vaultId, itemId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.items.delete(vaultId, itemId);
            return;
        });
    }
}
//# sourceMappingURL=op-connect.js.map